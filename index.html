<!DOCTYPE html>  
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Math Problems Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Responsive Meta Tag -->
    <style>
        /* Reset some default styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            position: relative; /* To position the Spelling button */
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        /* Animations */
        /* Animation for fading dots downward and back up */
        @keyframes fadeOutDownLoop {
            0% { opacity: 1; transform: translateY(0); }      /* Start fully visible */
            50% { opacity: 0; transform: translateY(10px); }  /* Midway invisible, moved 10px down */
            100% { opacity: 1; transform: translateY(0); }    /* End fully visible, back to original position */
        }

        /* Animation for moving dots right and then back left */
        @keyframes moveRightLeft {
            0% { opacity: 1; transform: translateX(0); }
            50% { opacity: 1; transform: translateX(10px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        /* Apply looping fade-down animation */
        .animate-fade {
            animation: fadeOutDownLoop 2s infinite;
        }

        /* Apply right-to-left animation with loop */
        .animate-slide {
            animation: moveRightLeft 2s infinite;
        }

        /* Shake Animation */
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        .animate-shake {
            animation: shake 0.5s;
        }

        /* Addition Animation */
        @keyframes moveUp {
            0% { top: 20px; opacity: 1; }
            50% { top: 0; opacity: 1; }
            51% { opacity: 0; }
            100% { top: 0; opacity: 0; }
        }

        .operand2-dots.animate-move-up {
            position: absolute;
            animation: moveUp 3s infinite;
        }

        .addition-container {
            position: relative;
            height: 40px; /* Adjust as needed */
        }

        .addition-container .operand-dots {
            position: absolute;
        }

        .addition-container .operand1-dots {
            top: 0; /* Keep stationary */
        }

        .addition-container .operand2-dots {
            top: 20px; /* Start slightly lower */
        }

        .total-dots {
            opacity: 0;
            position: absolute;
            top: 0;
        }

        .addition-container.show-total .total-dots {
            opacity: 1;
        }

        /* Dot Styles */
        .dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #333;
            border-radius: 50%;
            margin-right: 2px;
            margin-bottom: 2px;
        }

        /* Vertical Bar for Division Groups */
        .group-separator {
            display: inline-block;
            width: 2px;
            height: 10px;
            background-color: #333;
            margin: 0 5px;
            vertical-align: middle;
        }

        /* Styles for correct and incorrect answers */
        .correct {
            background-color: #d4edda !important;
            border-color: #28a745 !important;
            color: #155724 !important;
        }

        .incorrect {
            background-color: #f8d7da !important; /* Light red background */
            border-color: #dc3545 !important; /* Dark red border */
            color: #ffffff !important; /* White text for contrast */
        }

        /* Highlight */
        .highlight {
            background-color: #ffffcc;
        }

        /* Spelling Button */
        #spellingButton {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #1e90ff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            text-decoration: none;
        }

        #spellingButton:hover {
            background-color: #0d6efd;
        }

        /* Styles for the rest of the page */
        #scoreDisplay {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        #settingsForm {
            width: 100%;
            max-width: 800px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        #settingsForm > div {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 10px;
        }

        .settings-item {
            display: flex;
            align-items: center;
            margin: 5px 20px;
            font-size: 1em;
            position: relative; /* For tooltip positioning */
        }

        .settings-item label {
            margin-right: 10px;
        }

        .number-input {
            display: flex;
            align-items: center;
        }

        .number-input input[type="number"] {
            width: 60px;
            padding: 5px;
            margin: 0 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            text-align: center; /* Center-align the text */
        }

        .number-input button {
            background-color: #1e90ff;
            color: #fff;
            border: none;
            padding: 5px 10px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .number-input button:hover {
            background-color: #0d6efd;
        }

        #operatorSelection {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }

        #operatorSelection label {
            margin: 5px 20px; /* Increased margin for better spacing */
            display: flex;
            align-items: center;
            font-size: 1em;
            padding-left: 5px; /* Add padding for better spacing */
        }

        /* Styled Button */
        #generateProblems {
            background-color: #1e90ff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 10px;
        }

        #generateProblems:hover {
            background-color: #0d6efd;
        }

        /* Problems Area */
        #problemsArea {
            width: 100%;
            max-width: 800px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            table-layout: fixed;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
            vertical-align: top; /* Ensure top alignment for multi-line content */
        }

        th {
            background-color: #1e90ff;
            color: white;
        }

        td {
            background-color: #ffffff;
        }

        /* Ensure multiple lines in problem cell */
        .problem-text {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
            text-align: center; /* Center-align the problem text */
        }

        .visual-aid {
            display: block;
            color: #555;
            font-size: 0.9em;
            margin-top: 5px;
        }

        /* Center alignment when no visual aid */
        .problem-cell-no-visual {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 5px;
            border: 2px solid #1e90ff;
            border-radius: 5px;
            text-align: center;
            transition: border-color 0.3s ease;
            font-size: 1em;
        }

        input[type="text"]:focus,
        input[type="number"]:focus {
            border-color: #0d6efd;
            outline: none;
        }

        /* Tooltip Styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            padding: 15px;
            border-radius: 6px;
            font-size: 1.2em;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            /* Fade in tooltip */
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Responsive Design */
        @media (max-width: 800px) {
            #settingsForm {
                padding: 15px;
            }

            table, th, td {
                font-size: 0.9em;
            }

            input[type="text"] {
                font-size: 0.9em;
            }
        }


		/* Updated keyframes for operand2-dots */
		@keyframes operand2MoveUp {
			0% { top: 20px; opacity: 1; }
			50% { top: 0; opacity: 1; }
			50.1% { opacity: 0; }
			100% { top: 0; opacity: 0; }
		}

		.operand2-dots.animate-move-up {
			position: absolute;
			animation: operand2MoveUp 6s infinite;
		}

		/* New keyframes for total-dots */
		@keyframes totalDotsAppear {
			0% { opacity: 0; }
			50% { opacity: 0; }
			50.1% { opacity: 1; }
			100% { opacity: 1; }
		}

		.total-dots.animate-appear {
			position: absolute;
			top: 0;
			animation: totalDotsAppear 6s infinite;
		}


        @media (max-width: 600px) {
            #settingsForm {
                flex-direction: column;
                align-items: center;
            }

            #settingsForm > div {
                flex-direction: column;
                align-items: center;
            }

            #operatorSelection {
                flex-direction: column;
                align-items: center;
            }

            table, th, td {
                font-size: 0.8em;
            }

            input[type="text"] {
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <h1>Math Problems Generator</h1>

    <!-- Spelling button at the top right -->
    <a href="spelling.html">
        <button id="spellingButton">Spelling</button>
    </a>

    <div id="scoreDisplay">Score: 0 / 0</div>
    <form id="settingsForm" onsubmit="return false;">
        <div>
            <div class="settings-item">
                <label for="minNum">Min Number:</label>
                <div class="number-input">
                    <button type="button" id="minNumDecrease">-</button>
                    <input type="number" id="minNum" name="minNum" min="1" placeholder="1">
                    <button type="button" id="minNumIncrease">+</button>
                </div>
            </div>
            <div class="settings-item">
                <label for="maxNum">Max Number:</label>
                <div class="number-input">
                    <button type="button" id="maxNumDecrease">-</button>
                    <input type="number" id="maxNum" name="maxNum" min="1" placeholder="10">
                    <button type="button" id="maxNumIncrease">+</button>
                </div>
            </div>
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="allowNegativeAnswers" name="allowNegativeAnswers">
                    Allow Negative Answers
                </label>
            </div>
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="includeMissingOperands" name="includeMissingOperands">
                    Fill in the blanks
                </label>
            </div>
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="testMode" name="testMode">
                    Test Mode
                </label>
            </div>
            <div class="settings-item">
                <label>
                    <span class="tooltip">
                        <input type="checkbox" id="visualAids" name="visualAids" checked>
                        Visual Aids
                        <span class="tooltiptext">Shows visual aid for answers less than 10.</span>
                    </span>
                </label>
            </div>
        </div>
        <div id="operatorSelection">
            <span style="margin-right:20px; font-size:1em;">Select Operators:</span>
            <label>
                <input type="checkbox" id="addOperator" name="operators" value="+">
                &nbsp;+
            </label>
            <label>
                <input type="checkbox" id="subtractOperator" name="operators" value="-">
                &nbsp;-
            </label>
            <label>
                <input type="checkbox" id="multiplyOperator" name="operators" value="*">
                &nbsp;×
            </label>
            <label>
                <input type="checkbox" id="divideOperator" name="operators" value="/">
                &nbsp;÷
            </label>
        </div>
        <button type="button" id="generateProblems">Generate Problems</button>
    </form>
    <div id="problemsArea"></div>

    <script>
        // Global Variables
        let answerCells = [];
        let problemCells = [];
        let problemsData = [];
        let totalProblems = 0;
        let correctAnswers = 0;
        const emptyBox = '⬜'; // Define emptyBox as '⬜' for fill-in-the-blank

        // Function to generate dots based on number and return HTML
        function getDotsHTML(number) {
            if (isNaN(number) || number <= 0) return '';
            let dotsHTML = '';
            for (let i = 0; i < number; i++) {
                dotsHTML += '<span class="dot"></span>';
            }
            return dotsHTML;
        }

        // Function to get the correct operator symbol
        function getOperatorSymbol(operator) {
            switch (operator) {
                case '+':
                    return '+';
                case '-':
                    return '-';
                case '*':
                    return '×';
                case '/':
                    return '÷';
                default:
                    return operator;
            }
        }

        // Function to generate visual representation based on operator and operands
        function generateVisualAid(problemObj, isFillInTheBlank) {
            const { operator, operand1, operand2 } = problemObj;
            let visualAid = '';

            switch (operator) {
                case '+':
                    if (isFillInTheBlank) {
                        // (Existing code for fill-in-the-blank remains unchanged)
                    } else {
                        visualAid = 
                        `<div class="addition-container">
                            <div class="operand-dots operand1-dots">${getDotsHTML(operand1)}</div>
                            <div class="operand-dots operand2-dots">${getDotsHTML(operand2)}</div>
                            <div class="total-dots">${getDotsHTML(operand1 + operand2)}</div>
                        </div>`;
                    }
                    break;
                case '-':
                    visualAid = isFillInTheBlank
                        ? (problemObj.missingOperand === 'operand1'
                            ? `${emptyBox} - ${getDotsHTML(operand2)} = ${getDotsHTML(problemObj.answer2)}`
                            : `${getDotsHTML(operand1)} - ${emptyBox} = ${getDotsHTML(problemObj.answer2)}`)
                        : `${getDotsHTML(operand1)}`;
                    break;
                case '*':
                    if (isFillInTheBlank) {
                        visualAid = problemObj.missingOperand === 'operand1'
                            ? `${emptyBox} × ${operand2} =`
                            : `${operand1} × ${emptyBox} =`;
                    } else {
                        for (let i = 0; i < operand1; i++) {
                            visualAid += `${getDotsHTML(operand2)}${i < operand1 - 1 ? ' + ' : ''}`;
                        }
                    }
                    break;
                case '/':
                    if (isFillInTheBlank) {
                        if (problemObj.missingOperand === 'operand1') {
                            let quotient = problemObj.answer / operand2;
                            for (let i = 0; i < operand2; i++) {
                                visualAid += `${getDotsHTML(quotient)}${i < operand2 - 1 ? ' | ' : ''}`;
                            }
                            visualAid = `${emptyBox} ÷ ${getDotsHTML(operand2)} = ${visualAid}`;
                        }
                    } else {
                        let quotient = problemObj.answer;
                        for (let i = 0; i < operand2; i++) {
                            visualAid += `${getDotsHTML(quotient)}${i < operand2 - 1 ? ' | ' : ''}`;
                        }
                    }
                    break;
                default:
                    visualAid = '';
            }

            return visualAid;
        }

        // Function to generate a random integer between min and max (inclusive)
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Function to generate a single problem object
        function createProblem(operators, min, max, allowNegative, fillInTheBlanks) {
            let operator = operators[getRandomInt(0, operators.length - 1)];
            let operand1, operand2, answer, answer2, missingOperand = null;
            let result;

            switch (operator) {
                case '+':
                    operand1 = getRandomInt(min, max);
                    operand2 = getRandomInt(min, max);
                    result = operand1 + operand2;

                    if (fillInTheBlanks) {
                        missingOperand = Math.random() < 0.5 ? 'operand1' : 'operand2';
                       
                        if (missingOperand === 'operand1') {
                            answer = operand1;    // Missing operand’s value
                            operand1 = emptyBox;  // Hide operand1
                        } else {
                            answer = operand2;    // Missing operand’s value
                            operand2 = emptyBox;  // Hide operand2
                        }
                    } else {
                        answer = result;         // If no blanks, set answer to full result
                    }
                    break;
                case '-':
                    operand1 = getRandomInt(min, max);
                    operand2 = getRandomInt(min, max);
                    result = operand1 - operand2;
                    if (fillInTheBlanks) {
                        // Decide randomly which operand to hide
                        missingOperand = Math.random() < 0.5 ? 'operand1' : 'operand2';
                        if (missingOperand === 'operand1') {
                            // Ensure no negative answers if not allowed by swapping first
                            if (!allowNegative && operand1 < operand2) {
                                [operand1, operand2] = [operand2, operand1];
                                result = operand1 - operand2;
                            }
                            answer = operand1;
                            operand1 = emptyBox;
                        } else {
                            // missingOperand === 'operand2'
                            // Ensure no negative answers if not allowed
                            if (!allowNegative && operand1 < operand2) {
                                // Swap operands to make operand1 >= operand2
                                [operand1, operand2] = [operand2, operand1];
                                result = operand1 - operand2;
                            }
                            answer = operand2;
                            operand2 = emptyBox;
                        }
                    } else {
                        answer = result;
                    }
                    break;
                case '*':
                    operand1 = getRandomInt(min, max);
                    operand2 = getRandomInt(min, max);
                    result = operand1 * operand2;
                    if (fillInTheBlanks) {
                        // Decide randomly which operand to hide
                        missingOperand = Math.random() < 0.5 ? 'operand1' : 'operand2';
                        if (missingOperand === 'operand1') {
                            answer = operand1;
                            operand1 = emptyBox;
                        } else {
                            answer = operand2;
                            operand2 = emptyBox;
                        }
                    } else {
                        answer = result;
                    }
                    break;
                case '/':
                    // Ensure division problems adhere to min and max numbers
                    let possibleOperand2 = [];
                    for (let op2 = min; op2 <= max; op2++) {
                        if (op2 === 0) continue; // Avoid division by zero
                        // Check if there's at least one operand1 divisible by op2
                        for (let op1 = min; op1 <= max; op1++) {
                            if (op1 % op2 === 0) {
                                possibleOperand2.push(op2);
                                break;
                            }
                        }
                    }

                    if (possibleOperand2.length === 0) {
                        // No valid division problems can be generated with the current min and max
                        return null;
                    }

                    operand2 = possibleOperand2[getRandomInt(0, possibleOperand2.length - 1)];
                    let quotientMin = min;
                    let quotientMax = Math.floor(max / operand2);
                    if (quotientMax < quotientMin) {
                        quotientMax = quotientMin;
                    }

                    let quotient = getRandomInt(quotientMin, quotientMax);
                    operand1 = operand2 * quotient;
                    result = quotient;

                    if (fillInTheBlanks) {
                        missingOperand = Math.random() < 0.5 ? 'operand1' : 'operand2';
                        if (missingOperand === 'operand1') {
                            answer = operand1;
                            operand1 = emptyBox;
                        } else {
                            answer = operand2;
                            operand2 = emptyBox;
                        }
                    } else {
                        answer = result;
                    }
                    break;
                default:
                    operand1 = 0;
                    operand2 = 0;
                    result = 0;
                    answer = 0;
            }

            // If negative answers are not allowed, regenerate if answer is negative
            if (!allowNegative && answer < 0) {
                return createProblem(operators, min, max, allowNegative, fillInTheBlanks);
            }

            return {
                operator: operator,
                operand1: operand1,
                operand2: operand2,
                answer: answer,
                answer2: result,
                fillInTheBlanks: fillInTheBlanks,
                missingOperand: missingOperand,
                result: result, // Store the result for correct problem formatting
                problemCell: null, // To be assigned later
                answerInput: null  // To be assigned later
            };
        }

        // Function to handle answer input
        function handleAnswerInput(inputField) {
            let problemIndex = inputField.dataset.problemIndex;
            let problemObj = problemsData[problemIndex];
            if (!problemObj) return; // Safety check
            let userAnswer = inputField.value.trim();
            let correctAnswer = problemObj.answer.toString();
            let testMode = document.getElementById('testMode').checked;

            // Check if the user has entered enough digits before validating
            if (userAnswer.length < correctAnswer.length) {
                return; // Wait for more input
            }

            if (userAnswer === correctAnswer) {
                // Correct answer
                inputField.classList.remove('incorrect');
                inputField.classList.add('correct');
                if (inputField.dataset.answeredCorrectly === 'false') {
                    correctAnswers++;
                    inputField.dataset.answeredCorrectly = 'true';
                    updateScore();
                }
                if (testMode) {
                    // Disable the input to prevent changes
                    inputField.disabled = true;
                }

                // Update visual aid if Fill in the Blanks is enabled
                if (problemObj.fillInTheBlanks && !testMode) {
                    updateVisualAidWithAnswer(problemObj);
                }
                // Move to next input
                moveToNextInput(inputField);
            } else {
                // Incorrect answer
                inputField.classList.remove('correct');
                inputField.classList.add('incorrect', 'animate-shake'); // Apply shake animation

                // Clear the input field to make it blank
                inputField.value = '';

                // Remove the shake class after animation ends to allow re-triggering
                inputField.addEventListener('animationend', () => {
                    inputField.classList.remove('animate-shake');
                }, { once: true }); // Ensure the listener is removed after first trigger

                // Maintain the red background by keeping the 'incorrect' class
                // No need to change the background color; it remains as defined in CSS

                if (inputField.dataset.answeredCorrectly === 'true') {
                    correctAnswers--;
                    inputField.dataset.answeredCorrectly = 'false';
                    updateScore();
                }
                if (testMode) {
                    // Disable the input to prevent changes
                    inputField.disabled = true;

                    // Move to next input in Test Mode After Incorrect Answer
                    moveToNextInput(inputField);
                }
            }
        }

        // Function to trigger shake animation on a problem cell
        function animateShake(problemCell) {
            problemCell.classList.add('animate-shake');
            // Remove the class after animation completes to allow re-triggering
            problemCell.addEventListener('animationend', () => {
                problemCell.classList.remove('animate-shake');
            }, { once: true });
        }

        // Function to move focus to the next input field
        function moveToNextInput(currentInput) {
            const currentIndex = answerCells.indexOf(currentInput);
            if (currentIndex > -1 && currentIndex < answerCells.length - 1) {
                const nextInput = answerCells[currentIndex + 1];
                if (!nextInput.disabled) {
                    nextInput.focus();
                    nextInput.classList.add('highlight');
                }
            }
        }

        // Function to update the visual aid by revealing the answer in FIB
        function updateVisualAidWithAnswer(problemObj) {
            let visualAidElement = problemObj.problemCell.querySelector('.visual-aid');
            if (!visualAidElement) return;

            let updatedVisualAid = generateVisualAid(problemObj, true);
            visualAidElement.innerHTML = `${updatedVisualAid}`;
        }

        // Function to update the score display
        function updateScore() {
            let scoreDisplay = document.getElementById('scoreDisplay');
            scoreDisplay.textContent = `Score: ${correctAnswers} / ${totalProblems}`;
        }

        // Function to focus the next empty answer input
        function focusNextEmptyAnswer() {
            for (let i = 0; i < answerCells.length; i++) {
                if (answerCells[i].value.trim() === '' && !answerCells[i].disabled) {
                    answerCells[i].focus();
                    answerCells[i].classList.add('highlight');
                    return;
                }
            }
        }

        // Function to remove highlight from all inputs
        function removeHighlight() {
            for (let i = 0; i < answerCells.length; i++) {
                answerCells[i].classList.remove('highlight');
            }
        }

        // Event Listener for Generate Problems Button
        document.getElementById('generateProblems').addEventListener('click', generateProblems);

        // Function to generate problems based on settings
        function generateProblems() {
            // Clear previous problems and data
            let problemsArea = document.getElementById('problemsArea');
            problemsArea.innerHTML = '';
            answerCells = [];
            problemCells = [];
            problemsData = [];
            totalProblems = 0;
            correctAnswers = 0;
            updateScore();

            // Read settings
            let minNum = parseInt(document.getElementById('minNum').value);
            let maxNum = parseInt(document.getElementById('maxNum').value);
            let allowNegativeAnswers = document.getElementById('allowNegativeAnswers').checked;
            let fillInTheBlanksEnabled = document.getElementById('includeMissingOperands').checked;
            let testMode = document.getElementById('testMode').checked;
            let visualAidsEnabled = document.getElementById('visualAids').checked;

            // Validate min and max numbers
            if (isNaN(minNum) || isNaN(maxNum) || minNum > maxNum) {
                alert("Please ensure that Min Number and Max Number are valid and that Min Number is less than or equal to Max Number.");
                return;
            }

            // Get selected operators
            let operators = [];
            if (document.getElementById('addOperator').checked) operators.push('+');
            if (document.getElementById('subtractOperator').checked) operators.push('-');
            if (document.getElementById('multiplyOperator').checked) operators.push('*');
            if (document.getElementById('divideOperator').checked) operators.push('/');

            if (operators.length === 0) {
                alert("No operators selected. Please select at least one operator.");
                return;
            }

            // Validate Division Settings
            if (operators.includes('/')) {
                let divisionPossible = false;
                // Iterate through possible operand2 values
                for (let op2 = minNum; op2 <= maxNum; op2++) {
                    if (op2 === 0) continue; // Avoid division by zero
                    // Check if there's at least one operand1 divisible by op2
                    for (let op1 = minNum; op1 <= maxNum; op1++) {
                        if (op1 % op2 === 0) {
                            divisionPossible = true;
                            break;
                        }
                    }
                    if (divisionPossible) break;
                }
                if (!divisionPossible) {
                    alert("Invalid Min and Max numbers for division: No numbers in the range can be divided evenly without decimals. Please adjust the Min and Max numbers.");
                    return;
                }
            }
            // End of Validation

            let table = document.createElement('table');

            // Create table header
            let thead = document.createElement('thead');
            let headerRow = document.createElement('tr');
            let headers = ['Problem', 'Answer', 'Problem', 'Answer', 'Problem', 'Answer'];
            headers.forEach(text => {
                let th = document.createElement('th');
                th.textContent = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            let tbody = document.createElement('tbody');

            // Initialize a Set to track unique problems
            const generatedProblems = new Set();

            // Generate 10 rows with 3 problems each (total 30 problems)
            for (let row = 0; row < 10; row++) {
                let tr = document.createElement('tr');
                for (let col = 0; col < 3; col++) {
                    let problemObj;
                    let attempts = 0;
                    let maxAttempts = 10; // Increased attempts for better uniqueness
                    let identifier;

                    // Attempt to generate a unique problem up to maxAttempts times
                    do {
                        problemObj = createProblem(operators, minNum, maxNum, allowNegativeAnswers, fillInTheBlanksEnabled);
                        attempts++;
                        if (problemObj === null) {
                            // If createProblem returns null, skip to next problem
                            break;
                        }
                        // Create a unique identifier based on operator and operands (considering blanks)
                        identifier = `${problemObj.operator}:${
                            problemObj.operand1 === emptyBox ? 'blank' : problemObj.operand1
                        }:${
                            problemObj.operand2 === emptyBox ? 'blank' : problemObj.operand2
                        }`;
                        // If unique, add to the Set
                        if (!generatedProblems.has(identifier)) {
                            generatedProblems.add(identifier);
                            break;
                        }
                    } while (attempts < maxAttempts);

                    if (problemObj === null) {
                        // Unable to generate a valid problem, skip this cell
                        tr.appendChild(document.createElement('td')); // Empty cell
                        tr.appendChild(document.createElement('td')); // Empty cell
                        continue;
                    }

                    // Format problem text
                    let problemText = problemObj.fillInTheBlanks ? formatProblemWithBlank(problemObj) : formatFullProblem(problemObj);

                    // Create problem cell
                    let problemCell = document.createElement('td');
                    problemCell.innerHTML = `<span class="problem-text">${problemText}</span>`;

                    // Add Visual Aid if not in Test Mode and Visual Aids are enabled
                    if (!testMode && visualAidsEnabled) {
                        let visualAidHTML = generateVisualAid(problemObj, problemObj.fillInTheBlanks);
                        problemCell.innerHTML += `<span class="visual-aid">${visualAidHTML}</span>`;
                    } else {
                        // Add class to center the content when no visual aid
                        problemCell.classList.add('problem-cell-no-visual');
                    }

                    tr.appendChild(problemCell);
                    problemCells.push(problemCell);

                    // Create answer cell with input field
                    let answerCell = document.createElement('td');
                    let answerInput = document.createElement('input');
                    answerInput.type = 'number';
                    answerInput.inputMode = 'numeric';
                    answerInput.step = '1'; // Ensures only integer inputs

                    answerInput.dataset.answer = problemObj.answer;
                    answerInput.dataset.problemIndex = problemsData.length;
                    answerInput.dataset.fillInTheBlanks = problemObj.fillInTheBlanks;
                    answerInput.dataset.operator = problemObj.operator;
                    answerInput.dataset.answeredCorrectly = 'false';
                    answerInput.placeholder = problemObj.fillInTheBlanks ? 'Your Answer' : 'Answer';
                    answerInput.maxLength = problemObj.answer.toString().length; // Set maxlength based on answer length

                    // Add event listeners
                    answerInput.addEventListener('focus', function() {
                        removeHighlight();
                        this.classList.add('highlight');

                        let problemIndex = this.dataset.problemIndex;
                        let problemObj = problemsData[problemIndex];

                        // Start subtraction animation if this is a subtraction problem
                        if (this.dataset.operator === '-') {
                            // Start animation
                            animateSubtraction(problemObj.problemCell, problemObj.operand2);
                        }

                        // Start addition animation if this is an addition problem
                        if (this.dataset.operator === '+') {
                            // Start addition animation
                            animateAddition(problemObj.problemCell);
                        }
                    });

                    answerInput.addEventListener('blur', function() {
                        this.classList.remove('highlight');

                        let problemIndex = this.dataset.problemIndex;
                        let problemObj = problemsData[problemIndex];

                        // Stop subtraction animation if this is a subtraction problem
                        if (this.dataset.operator === '-') {
                            // Stop animation
                            stopSubtractionAnimation(problemObj.problemCell);
                        }

                        // Stop addition animation if this is an addition problem
                        if (this.dataset.operator === '+') {
                            // Stop addition animation
                            stopAdditionAnimation(problemObj.problemCell);
                        }
                    });

                    answerInput.addEventListener('input', function() {
                        handleAnswerInput(this);
                    });

                    // Handle Enter key navigation
                    answerInput.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter') {
                            event.preventDefault(); // Prevent form submission
                            if (this.value.trim() !== '') {
                                handleAnswerInput(this);
                            }
                        }
                    });

                    answerCell.appendChild(answerInput);
                    tr.appendChild(answerCell);
                    answerCells.push(answerInput);

                    // Store problem data
                    problemObj.problemCell = problemCell;
                    problemObj.answerInput = answerInput;
                    problemsData.push(problemObj);
                    totalProblems++;
                }
                tbody.appendChild(tr);
            }

            table.appendChild(tbody);
            problemsArea.appendChild(table);

            // Set focus to the first empty answer cell
            focusNextEmptyAnswer();
        }

        // Function to format problem with blank and display the complete equation with the answer
        function formatProblemWithBlank(problemObj) {
            let result = problemObj.result;
            if (problemObj.operator === '+') {
                if (problemObj.missingOperand === 'operand1') {
                    return `${emptyBox} + ${problemObj.operand2} = ${result}`;
                } else {
                    return `${problemObj.operand1} + ${emptyBox} = ${result}`;
                }
            } else if (problemObj.operator === '-') {
                if (problemObj.missingOperand === 'operand1') {
                    return `${emptyBox} - ${problemObj.operand2} = ${result}`;
                } else {
                    return `${problemObj.operand1} - ${emptyBox} = ${result}`;
                }
            } else if (problemObj.operator === '*') {
                if (problemObj.missingOperand === 'operand1') {
                    return `${emptyBox} × ${problemObj.operand2} = ${result}`;
                } else {
                    return `${problemObj.operand1} × ${emptyBox} = ${result}`;
                }
            } else if (problemObj.operator === '/') {
                if (problemObj.missingOperand === 'operand1') {
                    return `${emptyBox} ÷ ${problemObj.operand2} = ${result}`;
                } else {
                    return `${problemObj.operand1} ÷ ${emptyBox} = ${result}`;
                }
            } else {
                return `${problemObj.operand1} ${getOperatorSymbol(problemObj.operator)} ${problemObj.operand2} =`;
            }
        }

        // Function to format full problem without answer
        function formatFullProblem(problemObj) {
            return `${problemObj.operand1} ${getOperatorSymbol(problemObj.operator)} ${problemObj.operand2} =`;
        }

		// Function to animate addition (dots moving and combining)
		function animateAddition(problemCell) {
			const additionContainer = problemCell.querySelector('.addition-container');
			const operand2Dots = additionContainer.querySelector('.operand2-dots');
			const totalDots = additionContainer.querySelector('.total-dots');
			if (!operand2Dots || !totalDots) return;

			// Apply animation classes
			operand2Dots.classList.add('animate-move-up');
			totalDots.classList.add('animate-appear');
		}

		// Function to stop addition animation
		function stopAdditionAnimation(problemCell) {
			const additionContainer = problemCell.querySelector('.addition-container');
			const operand2Dots = additionContainer.querySelector('.operand2-dots');
			const totalDots = additionContainer.querySelector('.total-dots');
			if (!operand2Dots || !totalDots) return;

			// Remove animation classes
			operand2Dots.classList.remove('animate-move-up');
			totalDots.classList.remove('animate-appear');
		}

        // Function to stop subtraction animation
        function stopSubtractionAnimation(problemCell) {
            const visualAidElement = problemCell.querySelector('.visual-aid');
            if (!visualAidElement) return;

            // Remove both animation classes from all dots
            const dots = visualAidElement.querySelectorAll('.dot');
            dots.forEach(dot => {
                dot.classList.remove('animate-fade', 'animate-slide');
            });
        }

        // Function to animate subtraction (fade and slide)
        function animateSubtraction(problemCell, numberToFade) {
            const visualAidElement = problemCell.querySelector('.visual-aid');
            if (!visualAidElement) return;

            // Get all dots in the visual aid element
            const dots = Array.from(visualAidElement.querySelectorAll('.dot'));

            // Apply right-to-left animation to the rightmost dots
            const startFadeIndex = Math.max(0, dots.length - numberToFade);
            for (let i = startFadeIndex; i < dots.length; i++) {
                dots[i].classList.add('animate-slide'); // Apply right-to-left animation
            }
        }

        // Handle clicks outside answer input fields to focus next empty answer
        document.addEventListener('mousedown', function(event) {
            let isClickInsideAnswerInput = event.target.tagName === 'INPUT' && answerCells.includes(event.target);
            let isClickInsideSettings = event.target.closest('#settingsForm') !== null;
            if (!isClickInsideAnswerInput && !isClickInsideSettings) {
                focusNextEmptyAnswer();
            }
        });

        // Initial setup: Remove prefilled data
        window.onload = function() {
            document.getElementById('minNum').value = '';
            document.getElementById('maxNum').value = '';
            document.getElementById('addOperator').checked = false;
            document.getElementById('subtractOperator').checked = false;
            document.getElementById('multiplyOperator').checked = false;
            document.getElementById('divideOperator').checked = false;
        };

        // Event listeners for increment and decrement buttons
        document.getElementById('minNumIncrease').addEventListener('click', () => {
            let minNumInput = document.getElementById('minNum');
            minNumInput.value = parseInt(minNumInput.value || 0) + 1;
        });

        document.getElementById('minNumDecrease').addEventListener('click', () => {
            let minNumInput = document.getElementById('minNum');
            let newValue = parseInt(minNumInput.value || 0) - 1;
            minNumInput.value = newValue < 0 ? 0 : newValue;
        });

        document.getElementById('maxNumIncrease').addEventListener('click', () => {
            let maxNumInput = document.getElementById('maxNum');
            maxNumInput.value = parseInt(maxNumInput.value || 0) + 1;
        });

        document.getElementById('maxNumDecrease').addEventListener('click', () => {
            let maxNumInput = document.getElementById('maxNum');
            let newValue = parseInt(maxNumInput.value || 0) - 1;
            maxNumInput.value = newValue < 0 ? 0 : newValue;
        });
    </script>
</body>
</html>
