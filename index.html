<!DOCTYPE html>  
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Math Problems Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Responsive Meta Tag -->
    <style>
        /* Reset some default styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            position: relative; /* To position elements absolutely */
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        /* XP Bar */
        #xpBarContainer {
            width: 100%;
            max-width: 800px;
            background-color: #e0e0e0;
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            height: 30px;
            overflow: hidden;
        }

        #xpBar {
            background-color: #1e90ff;
            height: 100%;
            width: 0;
            transition: width 0.5s ease;
            border-radius: 10px 0 0 10px;
        }

        #xpText {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        /* Level Display */
        #levelDisplay {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            text-align: center;
        }

        /* Achievement Notification */
        #achievementNotification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #ffd700;
            color: #333;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 1000;
        }

        /* Achievement Modal */
        #achievementModal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1001; /* Above other content */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0, 0, 0, 0.5); /* Black w/ opacity */
        }

        #achievementModalContent {
            background-color: #fefefe;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 10px;
            position: relative;
        }

        #achievementModalClose {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
            cursor: pointer;
        }

        #achievementModalClose:hover,
        #achievementModalClose:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* Day Checklist */
        #dayChecklist {
            position: fixed;
            top: 100px;
            left: 20px;
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            z-index: 100;
            width: 120px;
        }

        #dayChecklist h3 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 1em;
        }

        #dayChecklist ul {
            list-style-type: none;
            padding: 0;
        }

        #dayChecklist li {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        #dayChecklist input[type="checkbox"] {
            margin-right: 10px;
        }

        /* End-of-Session Pop-Up */
        #sessionSummaryModal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1001; /* Above other content */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0, 0, 0, 0.5); /* Black w/ opacity */
        }

        #sessionSummaryContent {
            background-color: #fefefe;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 10px;
            position: relative;
            text-align: center;
        }

        #sessionSummaryContent h2 {
            margin-bottom: 20px;
        }

        #sessionSummaryContent button {
            background-color: #1e90ff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 20px;
        }

        #sessionSummaryContent button:hover {
            background-color: #0d6efd;
        }

        /* Animations */
        /* Animation for fading dots downward and back up */
        @keyframes fadeOutDownLoop {
            0% { opacity: 1; transform: translateY(0); }      /* Start fully visible */
            50% { opacity: 0; transform: translateY(10px); }  /* Midway invisible, moved 10px down */
            100% { opacity: 1; transform: translateY(0); }    /* End fully visible, back to original position */
        }

        /* Animation for moving dots right and then back left */
        @keyframes moveRightLeft {
            0% { opacity: 1; transform: translateX(0); }
            50% { opacity: 1; transform: translateX(10px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        /* Apply looping fade-down animation */
        .animate-fade {
            animation: fadeOutDownLoop 2s infinite;
        }

        /* Apply right-to-left animation with loop */
        .animate-slide {
            animation: moveRightLeft 2s infinite;
        }

        /* Shake Animation */
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

        .animate-shake {
            animation: shake 0.5s;
        }

        /* Addition Animation */
        @keyframes operand2MoveUpLoop {
            0% { top: 20px; opacity: 1; }
            50% { top: 0; opacity: 1; }
            50.1% { opacity: 0; }
            100% { top: 0; opacity: 0; }
        }

        @keyframes totalDotsAppearLoop {
            0% { opacity: 0; }
            50% { opacity: 0; }
            50.1% { opacity: 1; }
            100% { opacity: 1; }
        }

        @keyframes operand1FadeOutLoop {
            0% { opacity: 1; }
            50% { opacity: 1; }
            50.1% { opacity: 0; }
            100% { opacity: 0; }
        }

        .operand1-dots.animate-fade-out {
            animation: operand1FadeOutLoop 6s infinite;
        }

        .operand2-dots.animate-move-up {
            position: absolute;
            animation: operand2MoveUpLoop 6s infinite;
        }

        .total-dots.animate-appear {
            position: absolute;
            top: 0;
            animation: totalDotsAppearLoop 6s infinite;
        }

        .addition-container {
            position: relative;
            height: 40px; /* Adjust as needed */
        }

        .addition-container .operand-dots {
            position: absolute;
        }

        .addition-container .operand1-dots {
            top: 0; /* Keep stationary */
        }

        .addition-container .operand2-dots {
            top: 20px; /* Start slightly lower */
        }

        .total-dots {
            opacity: 0;
            position: absolute;
            top: 0;
        }

        /* Dot Styles */
        .dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #333;
            border-radius: 50%;
            margin-right: 2px;
            margin-bottom: 2px;
        }

        /* Vertical Bar for Division Groups */
        .group-separator {
            display: inline-block;
            width: 2px;
            height: 10px;
            background-color: #333;
            margin: 0 5px;
            vertical-align: middle;
        }

        /* Styles for correct and incorrect answers */
        .correct {
            background-color: #d4edda !important;
            border-color: #28a745 !important;
            color: #155724 !important;
        }

        .incorrect {
            background-color: #f8d7da !important; /* Light red background */
            border-color: #dc3545 !important; /* Dark red border */
            color: #ffffff !important; /* White text for contrast */
        }

        /* Highlight */
        .highlight {
            background-color: #ffffcc;
        }

        /* Spelling Button */
        #spellingButton {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #1e90ff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            text-decoration: none;
        }

        #spellingButton:hover {
            background-color: #0d6efd;
        }

        /* Styles for the rest of the page */
        #scoreDisplay {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        #streakDisplay {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #333;
            text-align: center;
        }

        #settingsForm {
            width: 100%;
            max-width: 800px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        #settingsForm > div {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 10px;
        }

        .settings-item {
            display: flex;
            align-items: center;
            margin: 5px 20px;
            font-size: 1em;
            position: relative; /* For tooltip positioning */
        }

        .settings-item label {
            margin-right: 10px;
        }

        .number-input {
            display: flex;
            align-items: center;
        }

		.number-input input[type="number"] {
			width: 60px;
			padding: 5px;
			margin: 0 5px;
			border: 1px solid #ccc;
			border-radius: 5px;
			text-align: center; /* Center-align the text */
		}

		/* Remove up/down arrows from number inputs */
		input[type=number]::-webkit-outer-spin-button,
		input[type=number]::-webkit-inner-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		input[type=number] {
			-moz-appearance: textfield;
		}

		.number-input button {
			background-color: #1e90ff;
			color: #fff;
			border: none;
			padding: 5px 10px;
			font-size: 1em;
			border-radius: 5px;
			cursor: pointer;
			transition: background-color 0.3s ease;
		}

		.number-input button:hover {
			background-color: #0d6efd;
		}

		/* Styles for Quick Set Buttons */
		.quick-set-button {
			background-color: #1e90ff;
			color: #fff;
			border: none;
			padding: 5px 10px;
			font-size: 1em;
			border-radius: 5px;
			cursor: pointer;
			margin: 0 5px;
			transition: background-color 0.3s ease;
		}

		.quick-set-button:hover {
			background-color: #0d6efd;
		}

		/* Container for Quick Set Buttons */
		.quick-set-container {
			display: flex;
			flex-wrap: wrap;
			gap: 10px; /* Space between buttons */
			margin-top: 10px;
		}

		.quick-set-button {
			flex: 1 0 100px; /* Buttons have a minimum width of 100px */
			text-align: center;
		}


        #operatorSelection {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }

        #operatorSelection label {
            margin: 5px 20px; /* Increased margin for better spacing */
            display: flex;
            align-items: center;
            font-size: 1em;
            padding-left: 5px; /* Add padding for better spacing */
        }

        /* Styled Button */
        #generateProblems,
        #resetProgressButton,
        #viewAchievementsButton {
            background-color: #1e90ff;
            color: #fff;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 10px;
            margin-right: 10px;
        }

        #generateProblems:hover,
        #viewAchievementsButton:hover {
            background-color: #0d6efd;
        }

        #resetProgressButton {
            background-color: #dc3545;
        }

        #resetProgressButton:hover {
            background-color: #c82333;
        }

        /* Problems Area */
        #problemsArea {
            width: 100%;
            max-width: 800px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            table-layout: fixed;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
            vertical-align: top; /* Ensure top alignment for multi-line content */
        }

        th {
            background-color: #1e90ff;
            color: white;
        }

        td {
            background-color: #ffffff;
        }

        /* Ensure multiple lines in problem cell */
        .problem-text {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
            text-align: center; /* Center-align the problem text */
        }

        .visual-aid {
            display: block;
            color: #555;
            font-size: 0.9em;
            margin-top: 5px;
        }

        /* Center alignment when no visual aid */
        .problem-cell-no-visual {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 5px;
            border: 2px solid #1e90ff;
            border-radius: 5px;
            text-align: center;
            transition: border-color 0.3s ease;
            font-size: 1em;
        }

        input[type="text"]:focus,
        input[type="number"]:focus {
            border-color: #0d6efd;
            outline: none;
        }

        /* Tooltip Styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            padding: 15px;
            border-radius: 6px;
            font-size: 1.2em;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            /* Fade in tooltip */
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Profile Selector */
        #profileContainer {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        #profileSelect {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-right: 10px;
        }

        #newProfileButton {
            background-color: #1e90ff;
            color: #fff;
            border: none;
            padding: 5px 10px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #newProfileButton:hover {
            background-color: #0d6efd;
        }

        /* Responsive Design */
        @media (max-width: 800px) {
            #settingsForm {
                padding: 15px;
            }

            table, th, td {
                font-size: 0.9em;
            }

            input[type="text"] {
                font-size: 0.9em;
            }
        }

        @media (max-width: 600px) {
            #settingsForm {
                flex-direction: column;
                align-items: center;
            }

            #settingsForm > div {
                flex-direction: column;
                align-items: center;
            }

            #operatorSelection {
                flex-direction: column;
                align-items: center;
            }

            table, th, td {
                font-size: 0.8em;
            }

            input[type="text"] {
                font-size: 0.8em;
            }

            #dayChecklist {
                position: relative;
                top: 0;
                left: 0;
                margin-bottom: 20px;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>Math Problems Generator</h1>

    <!-- Spelling button at the top right -->
    <a href="spelling.html">
        <button id="spellingButton">Spelling</button>
    </a>

    <!-- Day Checklist -->
    <div id="dayChecklist">
        <h3>Weekly Goals</h3>
        <ul>
            <li><input type="checkbox" id="monday"> Monday</li>
            <li><input type="checkbox" id="tuesday"> Tuesday</li>
            <li><input type="checkbox" id="wednesday"> Wednesday</li>
            <li><input type="checkbox" id="thursday"> Thursday</li>
            <li><input type="checkbox" id="friday"> Friday</li>
            <li><input type="checkbox" id="saturday"> Saturday</li>
            <li><input type="checkbox" id="sunday"> Sunday</li>
        </ul>
    </div>

    <!-- Profile Selector -->
    <div id="profileContainer">
        <select id="profileSelect"></select>
        <button id="newProfileButton">New Profile</button>
    </div>

    <!-- Level Display -->
    <div id="levelDisplay">Level 1</div>

    <!-- XP Bar -->
    <div id="xpBarContainer">
        <div id="xpBar"></div>
        <div id="xpText">0 XP / 100 XP</div>
    </div>

    <!-- Achievement Notification -->
    <div id="achievementNotification"></div>

    <!-- Achievement Modal -->
    <div id="achievementModal">
        <div id="achievementModalContent">
            <span id="achievementModalClose">&times;</span>
            <h2>Your Achievements</h2>
            <ul id="achievementList"></ul>
        </div>
    </div>

    <!-- End-of-Session Pop-Up -->
    <div id="sessionSummaryModal">
        <div id="sessionSummaryContent">
            <h2>Session Summary</h2>
            <p id="sessionSummaryText"></p>
            <button id="closeSessionSummaryButton">Start New Session</button>
        </div>
    </div>

    <div id="scoreDisplay">Score: 0 / 0</div>
    <div id="streakDisplay">Daily Streak: 0 days</div>
    <form id="settingsForm" onsubmit="return false;">
        <div>
            <div class="settings-item">
                <label for="minNum">Min Number:</label>
                <div class="number-input">
                    <button type="button" id="minNumDecrease">-</button>
                    <input type="number" id="minNum" name="minNum" min="1" placeholder="1">
                    <button type="button" id="minNumIncrease">+</button>
                </div>
            </div>
            <div class="settings-item">
                <label for="maxNum">Max Number:</label>
                <div class="number-input">
                    <button type="button" id="maxNumDecrease">-</button>
                    <input type="number" id="maxNum" name="maxNum" min="1" placeholder="10">
                    <button type="button" id="maxNumIncrease">+</button>
                </div>
            </div>
			<!-- Quick Set Buttons -->
			<div class="settings-item">
				<label>Quick Set:</label>
				<div class="quick-set-container">
					<button type="button" class="quick-set-button" data-min="1" data-max="5">1-5</button>
					<button type="button" class="quick-set-button" data-min="2" data-max="6">2-6</button>
					<button type="button" class="quick-set-button" data-min="3" data-max="7">3-7</button>
					<button type="button" class="quick-set-button" data-min="5" data-max="10">5-10</button>
					<button type="button" class="quick-set-button" data-min="10" data-max="20">10-20</button>
					<button type="button" class="quick-set-button" data-min="15" data-max="25">15-25</button>
					<button type="button" class="quick-set-button" data-min="20" data-max="30">20-30</button>
					<button type="button" class="quick-set-button" data-min="25" data-max="40">25-40</button>
					<button type="button" class="quick-set-button" data-min="30" data-max="50">30-50</button>
					<button type="button" class="quick-set-button" data-min="50" data-max="75">50-75</button>
					<button type="button" class="quick-set-button" data-min="75" data-max="100">75-100</button>
					<button type="button" class="quick-set-button" data-min="100" data-max="150">100-150</button>
				</div>
			</div>
			
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="allowNegativeAnswers" name="allowNegativeAnswers">
                    Allow Negative Answers
                </label>
            </div>
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="includeMissingOperands" name="includeMissingOperands">
                    Fill in the blanks
                </label>
            </div>
            <div class="settings-item">
                <label>
                    <input type="checkbox" id="testMode" name="testMode">
                    Test Mode
                </label>
            </div>
            <div class="settings-item">
                <label>
                    <span class="tooltip">
                        <input type="checkbox" id="visualAids" name="visualAids" checked>
                        Visual Aids
                        <span class="tooltiptext">Shows visual aids for regular problems with answers less than or equal to 10. Visual aids are not shown for fill-in-the-blank questions or test mode.</span>
                    </span>
                </label>
            </div>
        </div>
        <div id="operatorSelection">
            <span style="margin-right:20px; font-size:1em;">Select Operators:</span>
            <label>
                <input type="checkbox" id="addOperator" name="operators" value="+">
                &nbsp;+
            </label>
            <label>
                <input type="checkbox" id="subtractOperator" name="operators" value="-">
                &nbsp;-
            </label>
            <label>
                <input type="checkbox" id="multiplyOperator" name="operators" value="*">
                &nbsp;×
            </label>
            <label>
                <input type="checkbox" id="divideOperator" name="operators" value="/">
                &nbsp;÷
            </label>
        </div>
        <div>
            <button type="button" id="generateProblems">Generate Problems</button>
            <button type="button" id="viewAchievementsButton">View Achievements</button>
            <button type="button" id="resetProgressButton">Reset Progress</button>
        </div>
    </form>
    <div id="problemsArea"></div>

    <script>
        // Global Variables
        let answerCells = [];
        let problemCells = [];
        let problemsData = [];
        let totalProblems = 0;
        let correctAnswers = 0;
        const emptyBox = '⬜'; // Define emptyBox as '⬜' for fill-in-the-blank

		// XP and Leveling System
		let xp = 0;
		let level = 1;
		let xpForNextLevel = 100;
		let achievements = [];
		let consecutiveCorrect = 0;

		// Achievement Tracking Variables
		let totalCorrectAnswers = 0;
		let operationCorrectCounts = { '+': 0, '-': 0, '*': 0, '/': 0 };

        // Daily Target and Streak
        const dailyTarget = 30;
        let dailyStreak = 0;
        let weekCompleted = false;

        // Profiles
        let profiles = {};
        let currentProfile = null;

        // Function to generate dots based on number and return HTML
        function getDotsHTML(number) {
            if (isNaN(number) || number <= 0) return '';
            let dotsHTML = '';
            for (let i = 0; i < number; i++) {
                dotsHTML += '<span class="dot"></span>';
            }
            return dotsHTML;
        }

        // Function to get the correct operator symbol
        function getOperatorSymbol(operator) {
            switch (operator) {
                case '+':
                    return '+';
                case '-':
                    return '-';
                case '*':
                    return '×';
                case '/':
                    return '÷';
                default:
                    return operator;
            }
        }

		// Function to generate visual representation based on operator and operands
		function generateVisualAid(problemObj, isFillInTheBlank) {
			const { operator, operand1, operand2, result } = problemObj;
			let visualAid = '';

			// Do not generate visual aids for fill-in-the-blank questions
			if (isFillInTheBlank) {
				return '';
			}

			// Only generate visual aids if the answer is less than or equal to 10
			if (result > 10) {
				return '';
			}

            switch (operator) {
                case '+':
                    if (isFillInTheBlank) {
                        // (Existing code for fill-in-the-blank remains unchanged)
                    } else {
                        visualAid = 
                        `<div class="addition-container">
                            <div class="operand-dots operand1-dots">${getDotsHTML(operand1)}</div>
                            <div class="operand-dots operand2-dots">${getDotsHTML(operand2)}</div>
                            <div class="total-dots">${getDotsHTML(operand1 + operand2)}</div>
                        </div>`;
                    }
                    break;
                case '-':
                    visualAid = isFillInTheBlank
                        ? (problemObj.missingOperand === 'operand1'
                            ? `${emptyBox} - ${getDotsHTML(operand2)} = ${getDotsHTML(problemObj.answer2)}`
                            : `${getDotsHTML(operand1)} - ${emptyBox} = ${getDotsHTML(problemObj.answer2)}`)
                        : `${getDotsHTML(operand1)}`;
                    break;
                case '*':
                    if (isFillInTheBlank) {
                        visualAid = problemObj.missingOperand === 'operand1'
                            ? `${emptyBox} × ${operand2} =`
                            : `${operand1} × ${emptyBox} =`;
                    } else {
                        for (let i = 0; i < operand1; i++) {
                            visualAid += `${getDotsHTML(operand2)}${i < operand1 - 1 ? ' + ' : ''}`;
                        }
                    }
                    break;
                case '/':
                    if (isFillInTheBlank) {
                        if (problemObj.missingOperand === 'operand1') {
                            let quotient = problemObj.answer / operand2;
                            for (let i = 0; i < operand2; i++) {
                                visualAid += `${getDotsHTML(quotient)}${i < operand2 - 1 ? ' | ' : ''}`;
                            }
                            visualAid = `${emptyBox} ÷ ${getDotsHTML(operand2)} = ${visualAid}`;
                        }
                    } else {
                        let quotient = problemObj.answer;
                        for (let i = 0; i < operand2; i++) {
                            visualAid += `${getDotsHTML(quotient)}${i < operand2 - 1 ? ' | ' : ''}`;
                        }
                    }
                    break;
                default:
                    visualAid = '';
            }

            return visualAid;
        }

        // Function to generate a random integer between min and max (inclusive)
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Function to generate a single problem object
        function createProblem(operators, min, max, allowNegative, fillInTheBlanks) {
            let operator = operators[getRandomInt(0, operators.length - 1)];
            let operand1, operand2, answer, answer2, missingOperand = null;
            let result;

            switch (operator) {
                case '+':
                    operand1 = getRandomInt(min, max);
                    operand2 = getRandomInt(min, max);
                    result = operand1 + operand2;

                    if (fillInTheBlanks) {
                        missingOperand = Math.random() < 0.5 ? 'operand1' : 'operand2';
                       
                        if (missingOperand === 'operand1') {
                            answer = operand1;    // Missing operand’s value
                            operand1 = emptyBox;  // Hide operand1
                        } else {
                            answer = operand2;    // Missing operand’s value
                            operand2 = emptyBox;  // Hide operand2
                        }
                    } else {
                        answer = result;         // If no blanks, set answer to full result
                    }
                    break;
                case '-':
                    operand1 = getRandomInt(min, max);
                    operand2 = getRandomInt(min, max);
                    result = operand1 - operand2;
                    if (fillInTheBlanks) {
                        // Decide randomly which operand to hide
                        missingOperand = Math.random() < 0.5 ? 'operand1' : 'operand2';
                        if (missingOperand === 'operand1') {
                            // Ensure no negative answers if not allowed by swapping first
                            if (!allowNegative && operand1 < operand2) {
                                [operand1, operand2] = [operand2, operand1];
                                result = operand1 - operand2;
                            }
                            answer = operand1;
                            operand1 = emptyBox;
                        } else {
                            // missingOperand === 'operand2'
                            // Ensure no negative answers if not allowed
                            if (!allowNegative && operand1 < operand2) {
                                // Swap operands to make operand1 >= operand2
                                [operand1, operand2] = [operand2, operand1];
                                result = operand1 - operand2;
                            }
                            answer = operand2;
                            operand2 = emptyBox;
                        }
                    } else {
                        answer = result;
                    }
                    break;
                case '*':
                    operand1 = getRandomInt(min, max);
                    operand2 = getRandomInt(min, max);
                    result = operand1 * operand2;
                    if (fillInTheBlanks) {
                        // Decide randomly which operand to hide
                        missingOperand = Math.random() < 0.5 ? 'operand1' : 'operand2';
                        if (missingOperand === 'operand1') {
                            answer = operand1;
                            operand1 = emptyBox;
                        } else {
                            answer = operand2;
                            operand2 = emptyBox;
                        }
                    } else {
                        answer = result;
                    }
                    break;
                case '/':
                    // Ensure division problems adhere to min and max numbers
                    let possibleOperand2 = [];
                    for (let op2 = min; op2 <= max; op2++) {
                        if (op2 === 0) continue; // Avoid division by zero
                        // Check if there's at least one operand1 divisible by op2
                        for (let op1 = min; op1 <= max; op1++) {
                            if (op1 % op2 === 0) {
                                possibleOperand2.push(op2);
                                break;
                            }
                        }
                    }

                    if (possibleOperand2.length === 0) {
                        // No valid division problems can be generated with the current min and max
                        return null;
                    }

                    operand2 = possibleOperand2[getRandomInt(0, possibleOperand2.length - 1)];
                    let quotientMin = min;
                    let quotientMax = Math.floor(max / operand2);
                    if (quotientMax < quotientMin) {
                        quotientMax = quotientMin;
                    }

                    let quotient = getRandomInt(quotientMin, quotientMax);
                    operand1 = operand2 * quotient;
                    result = quotient;

                    if (fillInTheBlanks) {
                        missingOperand = Math.random() < 0.5 ? 'operand1' : 'operand2';
                        if (missingOperand === 'operand1') {
                            answer = operand1;
                            operand1 = emptyBox;
                        } else {
                            answer = operand2;
                            operand2 = emptyBox;
                        }
                    } else {
                        answer = result;
                    }
                    break;
                default:
                    operand1 = 0;
                    operand2 = 0;
                    result = 0;
                    answer = 0;
            }

            // If negative answers are not allowed, regenerate if answer is negative
            if (!allowNegative && answer < 0) {
                return createProblem(operators, min, max, allowNegative, fillInTheBlanks);
            }

            return {
                operator: operator,
                operand1: operand1,
                operand2: operand2,
                answer: answer,
                answer2: result,
                fillInTheBlanks: fillInTheBlanks,
                missingOperand: missingOperand,
                result: result, // Store the result for correct problem formatting
                problemCell: null, // To be assigned later
                answerInput: null  // To be assigned later
            };
        }

        // Function to handle answer input
        function handleAnswerInput(inputField) {
            let problemIndex = inputField.dataset.problemIndex;
            let problemObj = problemsData[problemIndex];
            if (!problemObj) return; // Safety check
            let userAnswer = inputField.value.trim();
            let correctAnswer = problemObj.answer.toString();
            let testMode = document.getElementById('testMode').checked;

            // Check if the user has entered enough digits before validating
            if (userAnswer.length < correctAnswer.length) {
                return; // Wait for more input
            }

            if (userAnswer === correctAnswer) {
                // Correct answer
                inputField.classList.remove('incorrect');
                inputField.classList.add('correct');
				if (inputField.dataset.answeredCorrectly === 'false') {
					correctAnswers++;
					totalCorrectAnswers++; // Increment total correct answers
					inputField.dataset.answeredCorrectly = 'true';
					updateScore();
					awardXP(problemObj);
					consecutiveCorrect++;
					// Update operation-specific correct counts
					let operator = problemObj.operator;
					if (operationCorrectCounts.hasOwnProperty(operator)) {
						operationCorrectCounts[operator]++;
					}
					checkAchievements();
					checkDailyTarget();
				}

                if (testMode) {
                    // Disable the input to prevent changes
                    inputField.disabled = true;
                }

                // Update visual aid if Fill in the Blanks is enabled
                if (problemObj.fillInTheBlanks && !testMode) {
                    updateVisualAidWithAnswer(problemObj);
                }
                // Move to next input
                moveToNextInput(inputField);
            } else {
                // Incorrect answer
                inputField.classList.remove('correct');
                inputField.classList.add('incorrect', 'animate-shake'); // Apply shake animation

                // Clear the input field to make it blank
                inputField.value = '';

                // Remove the shake class after animation ends to allow re-triggering
                inputField.addEventListener('animationend', () => {
                    inputField.classList.remove('animate-shake');
                }, { once: true }); // Ensure the listener is removed after first trigger

                if (inputField.dataset.answeredCorrectly === 'true') {
                    correctAnswers--;
                    inputField.dataset.answeredCorrectly = 'false';
                    updateScore();
                    consecutiveCorrect = 0;
                }
                if (testMode) {
                    // Disable the input to prevent changes
                    inputField.disabled = true;

                    // Move to next input in Test Mode After Incorrect Answer
                    moveToNextInput(inputField);
                }
            }

            // Check if all problems are answered
            if (areAllProblemsAnswered()) {
                showSessionSummary();
            }
        }

        // Function to check if all problems are answered
        function areAllProblemsAnswered() {
            return answerCells.every(input => input.dataset.answeredCorrectly === 'true');
        }

        // Function to show session summary
        function showSessionSummary() {
            let sessionSummaryText = document.getElementById('sessionSummaryText');
            sessionSummaryText.textContent = `You answered ${correctAnswers} out of ${totalProblems} questions correctly!`;

            document.getElementById('sessionSummaryModal').style.display = 'block';

            // Reset the problems after showing summary
            // We will wait until the user clicks the button to reset
        }

        // Function to reset the session
        function resetSession() {
            document.getElementById('sessionSummaryModal').style.display = 'none';
            // Clear problems and data
            let problemsArea = document.getElementById('problemsArea');
            problemsArea.innerHTML = '';
            answerCells = [];
            problemCells = [];
            problemsData = [];
            totalProblems = 0;
            correctAnswers = 0;
            updateScore();
            consecutiveCorrect = 0;
            focusNextEmptyAnswer();
        }

        // Event listener for closing session summary
        document.getElementById('closeSessionSummaryButton').addEventListener('click', function() {
            resetSession();
        });

        // Function to trigger shake animation on a problem cell
        function animateShake(problemCell) {
            problemCell.classList.add('animate-shake');
            // Remove the class after animation completes to allow re-triggering
            problemCell.addEventListener('animationend', () => {
                problemCell.classList.remove('animate-shake');
            }, { once: true });
        }

        // Function to move focus to the next input field
        function moveToNextInput(currentInput) {
            const currentIndex = answerCells.indexOf(currentInput);
            if (currentIndex > -1 && currentIndex < answerCells.length - 1) {
                const nextInput = answerCells[currentIndex + 1];
                if (!nextInput.disabled) {
                    nextInput.focus();
                    nextInput.classList.add('highlight');
                }
            }
        }

        // Function to update the visual aid by revealing the answer in FIB
        function updateVisualAidWithAnswer(problemObj) {
            let visualAidElement = problemObj.problemCell.querySelector('.visual-aid');
            if (!visualAidElement) return;

            let updatedVisualAid = generateVisualAid(problemObj, true);
            visualAidElement.innerHTML = `${updatedVisualAid}`;
        }

        // Function to update the score display
        function updateScore() {
            let scoreDisplay = document.getElementById('scoreDisplay');
            scoreDisplay.textContent = `Score: ${correctAnswers} / ${totalProblems}`;
        }

        // Function to focus the next empty answer input
        function focusNextEmptyAnswer() {
            for (let i = 0; i < answerCells.length; i++) {
                if (answerCells[i].value.trim() === '' && !answerCells[i].disabled) {
                    answerCells[i].focus();
                    answerCells[i].classList.add('highlight');
                    return;
                }
            }
        }

        // Function to remove highlight from all inputs
        function removeHighlight() {
            for (let i = 0; i < answerCells.length; i++) {
                answerCells[i].classList.remove('highlight');
            }
        }

        // Event Listener for Generate Problems Button
        document.getElementById('generateProblems').addEventListener('click', generateProblems);

        // Function to generate problems based on settings
        function generateProblems() {
            // Clear previous problems and data
            let problemsArea = document.getElementById('problemsArea');
            problemsArea.innerHTML = '';
            answerCells = [];
            problemCells = [];
            problemsData = [];
            totalProblems = 0;
            correctAnswers = 0;
            updateScore();
            consecutiveCorrect = 0;

            // Read settings
            let minNum = parseInt(document.getElementById('minNum').value);
            let maxNum = parseInt(document.getElementById('maxNum').value);
            let allowNegativeAnswers = document.getElementById('allowNegativeAnswers').checked;
            let fillInTheBlanksEnabled = document.getElementById('includeMissingOperands').checked;
            let testMode = document.getElementById('testMode').checked;
            let visualAidsEnabled = document.getElementById('visualAids').checked;

            // Validate min and max numbers
            if (isNaN(minNum) || isNaN(maxNum) || minNum > maxNum) {
                alert("Please ensure that Min Number and Max Number are valid and that Min Number is less than or equal to Max Number.");
                return;
            }

            // Get selected operators
            let operators = [];
            if (document.getElementById('addOperator').checked) operators.push('+');
            if (document.getElementById('subtractOperator').checked) operators.push('-');
            if (document.getElementById('multiplyOperator').checked) operators.push('*');
            if (document.getElementById('divideOperator').checked) operators.push('/');

            if (operators.length === 0) {
                alert("No operators selected. Please select at least one operator.");
                return;
            }

            // Validate Division Settings
            if (operators.includes('/')) {
                let divisionPossible = false;
                // Iterate through possible operand2 values
                for (let op2 = minNum; op2 <= maxNum; op2++) {
                    if (op2 === 0) continue; // Avoid division by zero
                    // Check if there's at least one operand1 divisible by op2
                    for (let op1 = minNum; op1 <= maxNum; op1++) {
                        if (op1 % op2 === 0) {
                            divisionPossible = true;
                            break;
                        }
                    }
                    if (divisionPossible) break;
                }
                if (!divisionPossible) {
                    alert("Invalid Min and Max numbers for division: No numbers in the range can be divided evenly without decimals. Please adjust the Min and Max numbers.");
                    return;
                }
            }
            // End of Validation

            let table = document.createElement('table');

            // Create table header
            let thead = document.createElement('thead');
            let headerRow = document.createElement('tr');
            let headers = ['Problem', 'Answer', 'Problem', 'Answer', 'Problem', 'Answer'];
            headers.forEach(text => {
                let th = document.createElement('th');
                th.textContent = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create table body
            let tbody = document.createElement('tbody');

            // Initialize a Set to track unique problems
            const generatedProblems = new Set();

            // Generate enough problems to meet the daily target
            let totalProblemCount = dailyTarget;
            let problemsPerRow = 3;
            let totalRows = Math.ceil(totalProblemCount / problemsPerRow);
            let problemCounter = 0;

            for (let row = 0; row < totalRows; row++) {
                let tr = document.createElement('tr');
                for (let col = 0; col < problemsPerRow; col++) {
                    if (problemCounter >= totalProblemCount) break;

                    let problemObj;
                    let attempts = 0;
                    let maxAttempts = 10; // Increased attempts for better uniqueness
                    let identifier;

                    // Attempt to generate a unique problem up to maxAttempts times
                    do {
                        problemObj = createProblem(operators, minNum, maxNum, allowNegativeAnswers, fillInTheBlanksEnabled);
                        attempts++;
                        if (problemObj === null) {
                            // If createProblem returns null, skip to next problem
                            break;
                        }
                        // Create a unique identifier based on operator and operands (considering blanks)
                        identifier = `${problemObj.operator}:${
                            problemObj.operand1 === emptyBox ? 'blank' : problemObj.operand1
                        }:${
                            problemObj.operand2 === emptyBox ? 'blank' : problemObj.operand2
                        }`;
                        // If unique, add to the Set
                        if (!generatedProblems.has(identifier)) {
                            generatedProblems.add(identifier);
                            break;
                        }
                    } while (attempts < maxAttempts);

                    if (problemObj === null) {
                        // Unable to generate a valid problem, skip this cell
                        tr.appendChild(document.createElement('td')); // Empty cell
                        tr.appendChild(document.createElement('td')); // Empty cell
                        continue;
                    }

                    // Format problem text
                    let problemText = problemObj.fillInTheBlanks ? formatProblemWithBlank(problemObj) : formatFullProblem(problemObj);

                    // Create problem cell
                    let problemCell = document.createElement('td');
                    problemCell.innerHTML = `<span class="problem-text">${problemText}</span>`;

                    // Add Visual Aid if not in Test Mode and Visual Aids are enabled
                    if (!testMode && visualAidsEnabled) {
                        let visualAidHTML = generateVisualAid(problemObj, problemObj.fillInTheBlanks);
                        if (visualAidHTML) {
                            problemCell.innerHTML += `<span class="visual-aid">${visualAidHTML}</span>`;
                        } else {
                            // Add class to center the content when no visual aid
                            problemCell.classList.add('problem-cell-no-visual');
                        }
                    } else {
                        // Add class to center the content when no visual aid
                        problemCell.classList.add('problem-cell-no-visual');
                    }

                    tr.appendChild(problemCell);
                    problemCells.push(problemCell);

                    // Create answer cell with input field
                    let answerCell = document.createElement('td');
                    let answerInput = document.createElement('input');
                    answerInput.type = 'number';
                    answerInput.inputMode = 'numeric';
                    answerInput.step = '1'; // Ensures only integer inputs

                    answerInput.dataset.answer = problemObj.answer;
                    answerInput.dataset.problemIndex = problemsData.length;
                    answerInput.dataset.fillInTheBlanks = problemObj.fillInTheBlanks;
                    answerInput.dataset.operator = problemObj.operator;
                    answerInput.dataset.answeredCorrectly = 'false';
                    answerInput.placeholder = problemObj.fillInTheBlanks ? 'Your Answer' : 'Answer';
                    answerInput.maxLength = problemObj.answer.toString().length; // Set maxlength based on answer length

                    // Add event listeners
                    answerInput.addEventListener('focus', function() {
                        removeHighlight();
                        this.classList.add('highlight');

                        let problemIndex = this.dataset.problemIndex;
                        let problemObj = problemsData[problemIndex];

                        // Start subtraction animation if this is a subtraction problem
                        if (this.dataset.operator === '-') {
                            // Start animation
                            animateSubtraction(problemObj.problemCell, problemObj.operand2);
                        }

                        // Start addition animation if this is an addition problem
                        if (this.dataset.operator === '+') {
                            // Start addition animation
                            animateAddition(problemObj.problemCell);
                        }
                    });

                    answerInput.addEventListener('blur', function() {
                        this.classList.remove('highlight');

                        let problemIndex = this.dataset.problemIndex;
                        let problemObj = problemsData[problemIndex];

                        // Stop subtraction animation if this is a subtraction problem
                        if (this.dataset.operator === '-') {
                            // Stop animation
                            stopSubtractionAnimation(problemObj.problemCell);
                        }

                        // Stop addition animation if this is an addition problem
                        if (this.dataset.operator === '+') {
                            // Stop addition animation
                            stopAdditionAnimation(problemObj.problemCell);
                        }
                    });

                    answerInput.addEventListener('input', function() {
                        handleAnswerInput(this);
                    });

                    // Handle Enter key navigation
                    answerInput.addEventListener('keydown', function(event) {
                        if (event.key === 'Enter') {
                            event.preventDefault(); // Prevent form submission
                            if (this.value.trim() !== '') {
                                handleAnswerInput(this);
                            }
                        }
                    });

                    answerCell.appendChild(answerInput);
                    tr.appendChild(answerCell);
                    answerCells.push(answerInput);

                    // Store problem data
                    problemObj.problemCell = problemCell;
                    problemObj.answerInput = answerInput;
                    problemsData.push(problemObj);
                    totalProblems++;
                    problemCounter++;
                }
                tbody.appendChild(tr);
            }

            table.appendChild(tbody);
            problemsArea.appendChild(table);

            // Set focus to the first empty answer cell
            focusNextEmptyAnswer();
        }

        // Function to format problem with blank and display the complete equation with the answer
        function formatProblemWithBlank(problemObj) {
            let result = problemObj.result;
            if (problemObj.operator === '+') {
                if (problemObj.missingOperand === 'operand1') {
                    return `${emptyBox} + ${problemObj.operand2} = ${result}`;
                } else {
                    return `${problemObj.operand1} + ${emptyBox} = ${result}`;
                }
            } else if (problemObj.operator === '-') {
                if (problemObj.missingOperand === 'operand1') {
                    return `${emptyBox} - ${problemObj.operand2} = ${result}`;
                } else {
                    return `${problemObj.operand1} - ${emptyBox} = ${result}`;
                }
            } else if (problemObj.operator === '*') {
                if (problemObj.missingOperand === 'operand1') {
                    return `${emptyBox} × ${problemObj.operand2} = ${result}`;
                } else {
                    return `${problemObj.operand1} × ${emptyBox} = ${result}`;
                }
            } else if (problemObj.operator === '/') {
                if (problemObj.missingOperand === 'operand1') {
                    return `${emptyBox} ÷ ${problemObj.operand2} = ${result}`;
                } else {
                    return `${problemObj.operand1} ÷ ${emptyBox} = ${result}`;
                }
            } else {
                return `${problemObj.operand1} ${getOperatorSymbol(problemObj.operator)} ${problemObj.operand2} =`;
            }
        }

        // Function to format full problem without answer
        function formatFullProblem(problemObj) {
            return `${problemObj.operand1} ${getOperatorSymbol(problemObj.operator)} ${problemObj.operand2} =`;
        }

        // Function to animate addition (dots moving and combining)
        function animateAddition(problemCell) {
            const additionContainer = problemCell.querySelector('.addition-container');
            const operand1Dots = additionContainer.querySelector('.operand1-dots');
            const operand2Dots = additionContainer.querySelector('.operand2-dots');
            const totalDots = additionContainer.querySelector('.total-dots');
            if (!operand1Dots || !operand2Dots || !totalDots) return;

            // Apply animation classes
            operand1Dots.classList.add('animate-fade-out');
            operand2Dots.classList.add('animate-move-up');
            totalDots.classList.add('animate-appear');
        }

        // Function to stop addition animation
        function stopAdditionAnimation(problemCell) {
            const additionContainer = problemCell.querySelector('.addition-container');
            const operand1Dots = additionContainer.querySelector('.operand1-dots');
            const operand2Dots = additionContainer.querySelector('.operand2-dots');
            const totalDots = additionContainer.querySelector('.total-dots');
            if (!operand1Dots || !operand2Dots || !totalDots) return;

            // Remove animation classes
            operand1Dots.classList.remove('animate-fade-out');
            operand2Dots.classList.remove('animate-move-up');
            totalDots.classList.remove('animate-appear');
        }

        // Function to stop subtraction animation
        function stopSubtractionAnimation(problemCell) {
            const visualAidElement = problemCell.querySelector('.visual-aid');
            if (!visualAidElement) return;

            // Remove both animation classes from all dots
            const dots = visualAidElement.querySelectorAll('.dot');
            dots.forEach(dot => {
                dot.classList.remove('animate-fade', 'animate-slide');
            });
        }

        // Function to animate subtraction (fade and slide)
        function animateSubtraction(problemCell, numberToFade) {
            const visualAidElement = problemCell.querySelector('.visual-aid');
            if (!visualAidElement) return;

            // Get all dots in the visual aid element
            const dots = Array.from(visualAidElement.querySelectorAll('.dot'));

            // Apply right-to-left animation to the rightmost dots
            const startFadeIndex = Math.max(0, dots.length - numberToFade);
            for (let i = startFadeIndex; i < dots.length; i++) {
                dots[i].classList.add('animate-slide'); // Apply right-to-left animation
            }
        }

        // Handle clicks outside answer input fields to focus next empty answer
        document.addEventListener('mousedown', function(event) {
            let isClickInsideAnswerInput = event.target.tagName === 'INPUT' && answerCells.includes(event.target);
            let isClickInsideSettings = event.target.closest('#settingsForm') !== null;
            if (!isClickInsideAnswerInput && !isClickInsideSettings) {
                focusNextEmptyAnswer();
            }
        });

        // Initial setup: Remove prefilled data
        window.onload = function() {
            document.getElementById('minNum').value = '';
            document.getElementById('maxNum').value = '';
            document.getElementById('addOperator').checked = false;
            document.getElementById('subtractOperator').checked = false;
            document.getElementById('multiplyOperator').checked = false;
            document.getElementById('divideOperator').checked = false;

            loadProfiles();
            updateDayChecklist();
            updateStreakDisplay();
        };

		// Event listeners for increment and decrement buttons
		document.getElementById('minNumIncrease').addEventListener('click', () => {
			let minNumInput = document.getElementById('minNum');
			minNumInput.value = parseInt(minNumInput.value || 0) + 1;
		});

		document.getElementById('minNumDecrease').addEventListener('click', () => {
			let minNumInput = document.getElementById('minNum');
			let newValue = parseInt(minNumInput.value || 0) - 1;
			minNumInput.value = newValue < 0 ? 0 : newValue;
		});

		// Event listeners for Quick Set Buttons
		document.querySelectorAll('.quick-set-button').forEach(button => {
			button.addEventListener('click', function() {
				let min = this.dataset.min;
				let max = this.dataset.max;
				document.getElementById('minNum').value = min;
				document.getElementById('maxNum').value = max;
			});
		});

        document.getElementById('maxNumIncrease').addEventListener('click', () => {
            let maxNumInput = document.getElementById('maxNum');
            maxNumInput.value = parseInt(maxNumInput.value || 0) + 1;
        });

        document.getElementById('maxNumDecrease').addEventListener('click', () => {
            let maxNumInput = document.getElementById('maxNum');
            let newValue = parseInt(maxNumInput.value || 0) - 1;
            maxNumInput.value = newValue < 0 ? 0 : newValue;
        });

        // XP and Leveling Functions
        function awardXP(problemObj) {
            let xpGained = 10; // Base XP

            // Increase XP based on difficulty (e.g., larger numbers, complex operators)
            let difficultyFactor = Math.max(problemObj.result, problemObj.operand1, problemObj.operand2);
            xpGained += Math.floor(difficultyFactor / 10);

            xp += xpGained;
            updateXPBar();
            saveProgress();
        }

        function updateXPBar() {
            while (xp >= xpForNextLevel) {
                xp -= xpForNextLevel;
                level++;
                xpForNextLevel = Math.floor(xpForNextLevel * 1.5);
                // Optionally unlock incentives here
            }
            let xpBar = document.getElementById('xpBar');
            let xpText = document.getElementById('xpText');
            let xpPercentage = (xp / xpForNextLevel) * 100;
            xpBar.style.width = xpPercentage + '%';
            xpText.textContent = `${xp} XP / ${xpForNextLevel} XP`;

            // Update level display
            document.getElementById('levelDisplay').textContent = `Level ${level}`;
        }

        // Achievements Functions
        function checkAchievements() {
            // Example achievements
            if (correctAnswers === 10 && !achievements.includes('First10Correct')) {
                achievements.push('First10Correct');
                showAchievement('Achievement Unlocked: First 10 Questions Correct!');
            }

            if (correctAnswers === 100 && !achievements.includes('First100Correct')) {
                achievements.push('First100Correct');
                showAchievement('Achievement Unlocked: 100 Questions Answered!');
            }

            if (consecutiveCorrect === 5 && !achievements.includes('5InARow')) {
                achievements.push('5InARow');
                showAchievement('Achievement Unlocked: 5 Perfect Answers in a Row!');
            }

            if (dailyStreak === 7 && !achievements.includes('PerfectWeek')) {
                achievements.push('PerfectWeek');
                showAchievement('Achievement Unlocked: Perfect Week!');
            }

            saveProgress();
        }

        function showAchievement(message) {
            let notification = document.getElementById('achievementNotification');
            notification.textContent = message;
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 5000);
        }

        // Save and Load Progress
		function saveProgress() {
			if (currentProfile) {
				profiles[currentProfile] = {
					xp: xp,
					level: level,
					xpForNextLevel: xpForNextLevel,
					achievements: achievements,
					dailyStreak: dailyStreak,
					weekCompleted: weekCompleted,
					dayChecklist: getDayChecklistState(),
					totalCorrectAnswers: totalCorrectAnswers, // Add this line
					operationCorrectCounts: operationCorrectCounts // Add this line
				};
				localStorage.setItem('mathGameProfiles', JSON.stringify(profiles));
			}
		}


        function loadProfiles() {
            profiles = JSON.parse(localStorage.getItem('mathGameProfiles')) || {};
            let profileSelect = document.getElementById('profileSelect');
            profileSelect.innerHTML = '';
            for (let profileName in profiles) {
                let option = document.createElement('option');
                option.value = profileName;
                option.textContent = profileName;
                profileSelect.appendChild(option);
            }
            if (Object.keys(profiles).length === 0) {
                createNewProfile('Default');
            } else {
                currentProfile = profileSelect.value;
                loadProfileData(currentProfile);
            }
        }

        function createNewProfile(profileName) {
            profiles[profileName] = {
                xp: 0,
                level: 1,
                xpForNextLevel: 100,
                achievements: [],
                dailyStreak: 0,
                weekCompleted: false,
                dayChecklist: {}
            };
            currentProfile = profileName;
            saveProgress();
            loadProfiles();
        }

		function loadProfileData(profileName) {
			let profileData = profiles[profileName];
			if (profileData) {
				xp = profileData.xp;
				level = profileData.level;
				xpForNextLevel = profileData.xpForNextLevel;
				achievements = profileData.achievements;
				dailyStreak = profileData.dailyStreak || 0;
				weekCompleted = profileData.weekCompleted || false;
				setDayChecklistState(profileData.dayChecklist || {});
				totalCorrectAnswers = profileData.totalCorrectAnswers || 0; // Add this line
				operationCorrectCounts = profileData.operationCorrectCounts || { '+': 0, '-': 0, '*': 0, '/': 0 }; // Add this line
				updateXPBar();
				updateDayChecklist();
				updateStreakDisplay();
			}
		}


        document.getElementById('profileSelect').addEventListener('change', function() {
            currentProfile = this.value;
            loadProfileData(currentProfile);
        });

        document.getElementById('newProfileButton').addEventListener('click', function() {
            let profileName = prompt('Enter new profile name:');
            if (profileName && !profiles[profileName]) {
                createNewProfile(profileName);
            } else if (profiles[profileName]) {
                alert('Profile name already exists.');
            }
        });

        // Reset Progress Button
        document.getElementById('resetProgressButton').addEventListener('click', function() {
            let password = prompt('Enter password to reset progress:');
            if (password === 'phillip') {
                xp = 0;
                level = 1;
                xpForNextLevel = 100;
                achievements = [];
                consecutiveCorrect = 0;
                dailyStreak = 0;
                weekCompleted = false;
                resetDayChecklist();
                updateXPBar();
                updateStreakDisplay();
                saveProgress();
                alert('Progress has been reset.');
            } else {
                alert('Incorrect password.');
            }
        });

		// View Achievements Button
		document.getElementById('viewAchievementsButton').addEventListener('click', function() {
			let achievementList = document.getElementById('achievementList');
			achievementList.innerHTML = '';
			for (let key in achievementsData) {
				let achievement = achievementsData[key];
				let li = document.createElement('li');
				li.textContent = achievement.title + ': ' + achievement.description;
				if (achievements.includes(key)) {
					li.style.color = 'green';
				} else {
					li.style.color = 'gray';
				}
				achievementList.appendChild(li);
			}
			document.getElementById('achievementModal').style.display = 'block';
		});

        // Close Achievement Modal
        document.getElementById('achievementModalClose').addEventListener('click', function() {
            document.getElementById('achievementModal').style.display = 'none';
        });

        // Close modal when clicking outside content
        window.addEventListener('click', function(event) {
            let modal = document.getElementById('achievementModal');
            if (event.target == modal) {
                modal.style.display = 'none';
            }
            let sessionModal = document.getElementById('sessionSummaryModal');
            if (event.target == sessionModal) {
                sessionModal.style.display = 'none';
            }
        });

// Achievement Data
const achievementsData = {
    // General Milestones
    'FirstSteps': {
        title: 'Getting Started',
        description: 'Complete your first math problem.',
        criteria: function() { return totalCorrectAnswers >= 1; }
    },
    'RisingStar': {
        title: 'Rising Star',
        description: 'Answer 10 math problems correctly.',
        criteria: function() { return totalCorrectAnswers >= 10; }
    },
    'Achiever': {
        title: 'Achiever',
        description: 'Successfully solve 50 math problems.',
        criteria: function() { return totalCorrectAnswers >= 50; }
    },
    'Master': {
        title: 'Master Mathematician',
        description: 'Answer 100 math problems correctly.',
        criteria: function() { return totalCorrectAnswers >= 100; }
    },
    'CenturyClub': {
        title: 'Century Club',
        description: 'Achieve 200 correct answers.',
        criteria: function() { return totalCorrectAnswers >= 200; }
    },
    // Operation-Specific Achievements
    // Addition
    'AdditionNovice': {
        title: 'Addition Novice',
        description: 'Solve 10 addition problems correctly.',
        criteria: function() { return operationCorrectCounts['+'] >= 10; }
    },
    'AdditionProdigy': {
        title: 'Addition Prodigy',
        description: 'Complete 50 addition problems accurately.',
        criteria: function() { return operationCorrectCounts['+'] >= 50; }
    },
    'AdditionMastery': {
        title: 'Addition Mastery',
        description: 'Achieve 100 correct addition answers.',
        criteria: function() { return operationCorrectCounts['+'] >= 100; }
    },
    // Subtraction
    'SubtractionNovice': {
        title: 'Subtraction Novice',
        description: 'Solve 10 subtraction problems correctly.',
        criteria: function() { return operationCorrectCounts['-'] >= 10; }
    },
    'SubtractionProdigy': {
        title: 'Subtraction Prodigy',
        description: 'Complete 50 subtraction problems accurately.',
        criteria: function() { return operationCorrectCounts['-'] >= 50; }
    },
    'SubtractionMastery': {
        title: 'Subtraction Mastery',
        description: 'Achieve 100 correct subtraction answers.',
        criteria: function() { return operationCorrectCounts['-'] >= 100; }
    },
    // Multiplication
    'MultiplicationNovice': {
        title: 'Multiplication Novice',
        description: 'Solve 10 multiplication problems correctly.',
        criteria: function() { return operationCorrectCounts['*'] >= 10; }
    },
    'MultiplicationProdigy': {
        title: 'Multiplication Prodigy',
        description: 'Complete 50 multiplication problems accurately.',
        criteria: function() { return operationCorrectCounts['*'] >= 50; }
    },
    'MultiplicationMastery': {
        title: 'Multiplication Mastery',
        description: 'Achieve 100 correct multiplication answers.',
        criteria: function() { return operationCorrectCounts['*'] >= 100; }
    },
    // Division
    'DivisionNovice': {
        title: 'Division Novice',
        description: 'Solve 10 division problems correctly.',
        criteria: function() { return operationCorrectCounts['/'] >= 10; }
    },
    'DivisionProdigy': {
        title: 'Division Prodigy',
        description: 'Complete 50 division problems accurately.',
        criteria: function() { return operationCorrectCounts['/'] >= 50; }
    },
    'DivisionMastery': {
        title: 'Division Mastery',
        description: 'Achieve 100 correct division answers.',
        criteria: function() { return operationCorrectCounts['/'] >= 100; }
    },
    // Add more achievements as needed
};

// Update the checkAchievements function
function checkAchievements() {
    for (let key in achievementsData) {
        if (!achievements.includes(key) && achievementsData[key].criteria()) {
            achievements.push(key);
            showAchievement('Achievement Unlocked: ' + achievementsData[key].title);
        }
    }
    saveProgress();
}


        // Day Checklist Functions
        function updateDayChecklist() {
            let today = new Date().getDay(); // 0 (Sunday) to 6 (Saturday)
            let dayIds = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

            // Reset on Monday
            if (today === 1 && !localStorage.getItem('weekReset')) {
                resetDayChecklist();
                localStorage.setItem('weekReset', 'true');
                weekCompleted = false;
            }

            if (today !== 1) {
                localStorage.removeItem('weekReset');
            }

            // Load checklist from profile
            let dayChecklist = getDayChecklistState();
            dayIds.forEach(dayId => {
                let checkbox = document.getElementById(dayId);
                checkbox.checked = dayChecklist[dayId] || false;
                checkbox.disabled = true;
            });
        }

        function getDayChecklistState() {
            let dayIds = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            let dayChecklist = {};
            dayIds.forEach(dayId => {
                let checkbox = document.getElementById(dayId);
                dayChecklist[dayId] = checkbox.checked;
            });
            return dayChecklist;
        }

        function setDayChecklistState(state) {
            let dayIds = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            dayIds.forEach(dayId => {
                let checkbox = document.getElementById(dayId);
                checkbox.checked = state[dayId] || false;
                checkbox.disabled = true;
            });
        }

        function resetDayChecklist() {
            let dayIds = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            dayIds.forEach(dayId => {
                let checkbox = document.getElementById(dayId);
                checkbox.checked = false;
                checkbox.disabled = true;
            });
            dailyStreak = 0;
            updateStreakDisplay();
            saveProgress();
        }

        function checkDailyTarget() {
            if (correctAnswers >= dailyTarget && !isTodayChecked()) {
                markTodayAsCompleted();
                dailyStreak++;
                checkWeekCompletion();
                updateStreakDisplay();
                saveProgress();
                showAchievement('Daily Target Achieved!');
                awardDailyBonusXP();
            }
        }

        function isTodayChecked() {
            let todayId = getTodayId();
            let checkbox = document.getElementById(todayId);
            return checkbox.checked;
        }

        function markTodayAsCompleted() {
            let todayId = getTodayId();
            let checkbox = document.getElementById(todayId);
            checkbox.checked = true;
            saveProgress();
        }

        function getTodayId() {
            let today = new Date().getDay(); // 0 (Sunday) to 6 (Saturday)
            let dayIds = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            return dayIds[today];
        }

        function updateStreakDisplay() {
            let streakDisplay = document.getElementById('streakDisplay');
            streakDisplay.textContent = `Daily Streak: ${dailyStreak} days`;
        }

        function checkWeekCompletion() {
            let dayChecklist = getDayChecklistState();
            let allDaysCompleted = Object.values(dayChecklist).every(checked => checked);
            if (allDaysCompleted && !weekCompleted) {
                weekCompleted = true;
                achievements.push('PerfectWeek');
                showAchievement('Achievement Unlocked: Perfect Week!');
                saveProgress();
            }
        }

        function awardDailyBonusXP() {
            let bonusXP = 50;
            xp += bonusXP;
            updateXPBar();
            saveProgress();
            showAchievement(`Bonus XP Awarded: ${bonusXP} XP`);
        }
    </script>
</body>
</html>
